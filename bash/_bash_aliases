#!/usr/bin/env bash
# vim: set tabstop=2 shiftwidth=2 foldmethod=marker:

# ~/.profile or ~/.bash_profile read only by interactive shells
# ~/.profile is not read if ~/.bash_profile or ~/.bash_login exists.
# look into the dropbox-only phpenv_phpbuild branch for a sane .bash_profile

export DOTFILESREPO=$(readlink -f $( dirname $(readlink -f "${BASH_SOURCE[0]}"))"/..")
# source an extra file for non aliases/function stuff
if [ -f ~/.bash_extras ]; then
    . ~/.bash_extras
fi
# source drush aliases and completion
if [ -f ~/.drush_bashrc  ]; then
    . ~/.drush_bashrc
fi

# aliases {{{
alias ccat='pygmentize -O style=monokai -f console256 -g'
alias L='less -R'
alias df='df -h'
alias l='ls -CF --group-directories-first'
alias ll='ls -AlFh --group-directories-first'
alias ls='ls --color=auto --group-directories-first'
alias sl=ls
alias fire='firefox -Profilemanager -no-remote &> /dev/null &'
function cc () {
  if [ -z "$1" ]; then
    echo "Error: Argument missing. Specify a chrome session id"
    return 1;
  fi
  dirname=$1
  google-chrome --user-data-dir=/home/grota/.config/google-chrome_others/$dirname &> /dev/null &
}
alias pg='ps aux|grep '
alias pw='pwsafe -Eup -l'
alias pwc='pwsafe -px'
alias rstty='stty start undef stop undef'
alias ..="cd .."
alias ..2="cd ../.."
alias ..3="cd ../../.."
alias ..4="cd ../../../.."
alias ..5="cd ../../../../.."
alias cd..="cd ../"
alias cd...="cd ../.."
alias cd....="cd ../../.."
alias cd.....="cd ../../../.."
alias cd......="cd ../../../../.."
alias bc='bc -l'
alias grep='grep -n --exclude-dir=.svn --exclude-dir=.git '
# there's a ss bin but that's ok for me
alias ss='sudo su -'
# {tl,ll,rl}php log {{{
alias tlphp='tail -F /tmp/php5_apache_errorlog.log'
alias llphp='less /tmp/php5_apache_errorlog.log'
alias rlphp='sudo rm /tmp/php5_apache_errorlog.log'
#}}}
#alias rmine='RUBYMINE_JDK=~/Downloads/jdk1.6.0_30 mine &> /dev/null &'
#alias storm='WEBIDE_JDK=~/Downloads/jdk1.6.0_30 pstorm &> /dev/null &'
# Acer specific {{{
alias toff='xinput --disable "SynPS/2 Synaptics TouchPad"'
alias ton='xinput --enable "SynPS/2 Synaptics TouchPad"'
alias koff='xinput --disable "AT Translated Set 2 keyboard"'
alias kon='xinput --enable "AT Translated Set 2 keyboard"'
alias don='xrandr --output HDMI1 --auto --right-of LVDS1'
alias doff='xrandr --output HDMI1 --off'
alias auext='pactl set-card-profile 0 output:hdmi-stereo+input:analog-stereo'
alias auint='pactl set-card-profile 0 output:analog-stereo+input:analog-stereo'
#}}}
alias unmute='amixer set Speaker,0 unmute &> /dev/null ; amixer set Speaker,0 100% &> /dev/null'

# vim aliases {{{
# aka: vim standalone
alias vs="stty start undef stop undef && exec_scmb_expand_args $(which 2>/dev/null vim)"
# vims function to create/reuse vim server process
function vims {
  vim_orig=$(which 2>/dev/null vim)
  $vim_orig --serverlist | grep -q TROLOLOL
  # if server is running
  if [ $? -eq 0 ]; then
      $vim_orig --servername TROLOLOL --remote-silent "$@"
  else
      $vim_orig "$@" --servername TROLOLOL
  fi
}
alias vi="stty start undef stop undef && exec_scmb_expand_args vims"
alias vim="stty start undef stop undef && exec_scmb_expand_args vims"

# alias for v, vim wrapper at https://github.com/rupa/v.git
# aka: v list standalone
alias vls='v -l'
# aka: v list, reuse vim server session
alias vl='vim="eval $(type vims | tail -n +2); vims" v -l'
#}}}

#git aliases {{{
alias gg='git grep --break --heading --line-number'
alias gbv='git branch -avv'
alias gbf='git branch -f'
alias gau='git add -u'
alias gdcw='git diff --cached --word-diff --'
alias gl='git --no-pager l -n12'
alias k='git --no-pager ll -n12'
alias gk='gitk --all&'
alias gsts='git stash save '
alias gst='git stash list'
alias gstp='git stash pop --index'
alias gl1p="git log -1 -p"
# from scm_breeze
alias gsubrm="git_submodule_rm"
# c --rebuild to rebuild the cache
function _git_abbrev_hash_complete () {
  local curw MAX_REVS
  MAX_REVS=10
  COMPREPLY=()
  if [[ $COMP_CWORD == 2 ]]; then
    return
  fi
  IFS=$'\n'
  curw=${COMP_WORDS[COMP_CWORD]}
  # display a reminder, on first tab press (9 is the ascii value of TAB, see man bash, COMP_TYPE)
  if [[ $COMP_TYPE == 9 && $curw == '' ]]; then
    echo
    git --no-pager log --oneline -n${MAX_REVS}
  fi
  COMPREPLY=($(compgen -W '$(git log --pretty=format:%h -n'$MAX_REVS')' -- $curw))
  IFS=$' \t\n'
}
complete -F _git_abbrev_hash_complete gsf
complete -F _git_abbrev_hash_complete gl1p
# from scm_breeze
__define_git_completion gbf branch
complete -o default -o nospace -F _git_gbf_shortcut gbf
alias fzf="ruby --disable-gems "${DOTFILESREPO}"/bin/fzf/fzf"

function _my_fzf_dir_completion() {
  local cur prev MAX_NUM_OF_DIRS match_fav match match_dir
  # save the cursor position, see below as to why
  tput sc
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  IFS=$'\n'
  MAX_NUM_OF_DIRS=1000;
  # use only "favorites" for home
  if [[ "$PWD" != "$HOME" ]]; then
    match_dir="$(find_breadth_first_dirs $MAX_NUM_OF_DIRS)"
  else
    match_dir=""
  fi
  match_fav="$(tac $AUTOJUMP_DATA_DIR/autojump.txt|cut -f 2|sort)"
  match=$(echo -e "$match_fav\r\n$match_dir"| fzf -q "$cur")
  # don't specify $cur after the --, otherwise compgen filters out
  # unmatching (wrt $cur) paths that instead we want
  COMPREPLY=($(compgen -W "$match" --))
  IFS=$' \t\n'
  # ruby's curses stdlib does not play well with the cursor position,
  # we saved the position before and now we restore it
  tput rc
}

for cmd in "cd"; do
  complete -F _my_fzf_dir_completion $cmd
done

# This function finds the directories below the current one in
# a breadth-first fashion, this is because we want to be sure to
# get the shallowest dirs. Doing find ... | head -n 2000
# stops find after 2000 results but does not guarantee that we
# end up with the shallowest ones.
# This is wasteful but there doesn't seems to be a better way
# Optional param: MAX_RESULTS
function find_breadth_first_dirs () {
  local result depth MAX_RESULTS level_result
  depth=0
  # use a default for MAX_RESULTS if not provided
  if [ -z "$1" ]; then
    MAX_RESULTS=2000
  else
    MAX_RESULTS=$1
  fi
  level_result=1
  while [[ ( -n "$level_result" ) ]]; do
    depth=$((depth + 1))
    # execute find for the current level depth
    level_result=$(_find_for_level $depth)
    # stupid hack to avoid a newline at the beginning
    if [[ $depth -lt 2 ]]; then
      result+=$(echo "${level_result}")
    else
      result+=$(echo -e "\r\n${level_result}")
    fi
    # stop and prune if we reached the maximum
    if [[ ( $(echo "$result" | wc -l) -gt $MAX_RESULTS ) ]]; then
      result=$(echo "$result" | head -n $MAX_RESULTS)
    fi
  done
  # bash functions are stupid, this is the only way of returning that I could find
  echo "$result"
}

# Utility function used by find_breadth_first_dirs that finds dirs at level x, where x is the input param
function _find_for_level () {
  local temp
  if [ -z "$1" ]; then return 1; fi
  # Using -regex '\./.git.*' -prune doesn't seem to work when using maxdepth/mindepth
  temp=$(find -maxdepth "$1" -mindepth "$1" -type d -print 2> /dev/null| \grep -v '\.git'| cut -b 3-)
  echo "$temp"
}
#}}}


# old stuff, still used {{{
#alias STO='sudo mdadm -S /dev/md0'
#alias STA='sudo mdadm -As /dev/md0'
#alias vci='vi config.inc.php'
#alias c='cat /proc/mdstat'
#alias rs='rsync -av --delete'
#alias k='kompare -no -'
#alias svnd='svn diff --diff-cmd diff | colordiff | less -r'
#xmessage -nearmouse "Some important message"
#}}}
#}}}

# functions {{{
function rec() {
  if [ -z "$1" ]; then
    echo 'provide an output file'
    return
  fi
  count=4
  while [ $count -gt 0  ]; do
    echo $count ...
    count=$(( $count - 1  ))
    sleep 1
  done
  gst-launch-1.0 -e pulsesrc device="alsa_output.pci-0000_00_1b.0.analog-surround-40.monitor" ! audioconvert ! lamemp3enc target=1 bitrate=128 cbr=true ! filesink location="${1}.mp3"
}
function mkcd() { mkdir -p "$@" && eval cd "\"\$$#\""; }
function fixperms() {
  APACHEUSER=`ps aux | \grep -E '[a]pache|[h]ttpd' | \grep -v root | head -1 | cut -d\  -f1`
  sudo setfacl -R -m u:$APACHEUSER:rwX -m u:`whoami`:rwX "$@"
  sudo setfacl -dR -m u:$APACHEUSER:rwX -m u:`whoami`:rwX "$@"
}
#}}}
